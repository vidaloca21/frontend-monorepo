# 프로젝트 개요

### Turborepo, pnpm, Next.js 기반 모노레포 환경 구성 예제입니다.

### **1. 프로젝트 개요**

**개요**

본 프로젝트는 Next.js / React 기반 신규 프로젝트 착수 시, 다양한 프로젝트에서 재사용 가능한 공통 기반을 마련하는 것을 목표로 합니다.

이를 위해 효율적인 의존성 관리와 일관된 디자인 시스템 운영을 지원하며, 초기 설정에 드는 불필요한 공수를 줄이고 개발자 간 협업 효율과 프로젝트 일관성을 높이고자 제작되었습니다.

**목적**

- Next.js / React 기반 애플리케이션과 공통 패키지를 하나의 리포지토리에서 통합 관리
- 공통 모듈/설정을 공유해 재사용성·일관성·확장성 강화
- 신규/외부 인원이 와도 빠르게 진입 가능한 표준 개발 환경 제공

**프로젝트 실행**

```bash
pnpm install    # 의존성 설치

pnpm dev        # 모든 apps 병렬 실행
pnpm dev:core-app   # core-app만 실행

pnpm run:storybook  # storybook 실행
```

### **2. 프로젝트 구성**

**모노레포**

이 프로젝트는 Turborepo + pnpm을 기반으로 한 모노레포(monorepo) 구조로 구성되어 있습니다.

**모노레포를 채택한 이유**

- 여러 앱과 라이브러리를 단일 저장소에서 관리해 일관된 개발 경험 확보
- 공통 설정과 의존성을 공유하여 중복 최소화 및 관리 용이성 확보
- 기능별 패키지를 모듈화하여 재사용성과 확장성 강화
- 변경 사항을 한 리포에서 추적할 수 있어 가시성 및 협업 효율성 증대

**모노레포 장점**

- **통합 빌드/테스트 파이프라인:** Turborepo가 의존성 그래프 기반으로 영향 범위만 빌드/테스트
- **캐시 활용:** 로컬/원격 캐시로 빌드와 CI 속도 개선
- **패키지 간 일관성:** syncpack + pnpm workspace로 버전 관리 표준화
- **온보딩 단순화:** 신규 개발자가 단일 리포를 클론하여 바로 전체 환경 실행 가능

**주요 디렉토리**

- apps/: 실행 애플리케이션
- packages/: 재사용 라이브러리/설정 모듈
  - core-ui: shadcn/UI, 공통 컴포넌트, Storybook 패키지
  - core-lib: 공통 유틸/도메인 모듈(http-client, store, utils 등)
  - config: eslint, prettier, typescript 설정 모음

**주요 루트 구성 파일**

- turbo.json: Turborepo 파이프라인/캐시 설정
- pnpm-workspace.yaml: 워크스페이스(패키지 경로) 정의
- package.json: 공통 스크립트/엔진/툴 버전 등 워크스페이스 전체 오케스트레이션

### **3. 모노레포 관리 도구: Turborepo, syncpack**

**Turborepo**

**역할:**

- JavaScript와 TypeScript 코드 베이스의 모노레포를 위한 고성능 빌드 시스템
- 모노레포 환경에서 각 패키지의 빌드·테스트·타입체크·실행을 위한 통합 오케스트레이션 도구
- package.json: 공통 스크립트/엔진/툴 버전 등 워크스페이스 전체 오케스트레이션

**특징:**

- **의존성 그래프 기반 실행:** 변경된 패키지 및 영향 범위만 증분 빌드/테스트
- **병렬 실행:** 독립적인 태스크를 동시에 처리하여 CI/CD 속도 향상
- **로컬·원격 캐시 재사용:** 동일 입력/출력에 대해 빌드·테스트 결과를 재활용, 파이프라인 시간 단축
- **표준화된 태스크 관리:** dev, build, lint, test, storybook 등을 일관된 방식으로 실행
- **확장성:** 소규모부터 대규모 모노레포까지 유연하게 대응 가능

참고자료: [Turborepo로 모노레포 개발 경험 향상하기](https://engineering.linecorp.com/ko/blog/monorepo-with-turborepo)

**syncpack**

- **역할:** 워크스페이스 전반의 의존성 버전 일관성 유지
- **이점:** 장기 운영에서 버전 드리프트로 인한 보안/호환성 리스크 감소
- **사용 예시:**

```bash
pnpm syncpack list-mismatches # 버전 불일치 확인

pnpm syncpack fix-mismatches # 자동 정렬 후 pnpm i
```

### **4.패키지 매니저: pnpm**

**pnpm 선정 이유**

- 하드링크/심볼릭 링크 + 콘텐츠 주소형 저장소를 활용하여 설치 속도가 빠르고 디스크 사용 효율이 높음
- Node.js 기본 해상과 유사하게 동작해 Next.js, Storybook, Vite, TS 빌드 도구 등과 호환성이 뛰어남
- 워크스페이스 기능이 단순하고 workspace:\* 버전을 이용해 내부 패키지를 명확히 연결할 수 있음
- 팀 온보딩이 쉽고, 별도의 복잡한 설정이 필요하지 않아 운영이 단순함

**Yarn Berry(PnP/Zero‑Installs)와의 비교**

**Yarn Berry 장점**

- **PnP(Plug’n’Play):** node_modules 없이 .pnp.cjs로 패키지를 해상하여 의존성 관리 속도가 빠름
- **Zero‑Installs:** .yarn/cache에 의존성을 zip으로 보관하고 이를 Git에 커밋하면, 브랜치 전환이나 CI 환경에서도 install 과정 없이 즉시 실행 가능
- **이점:** 설치 속도와 재현성이 뛰어나고, CI/CD 환경에서 네트워크 의존성을 크게 줄일 수 있음

**Yarn Berry 고려사항**

- 일부 플러그인·툴체인과의 호환성 문제가 발생할 수 있음 (특히 node_modules 구조를 가정하는 도구들)
- .yarn/cache를 Git에 포함하면 저장소 크기가 커지고, 레포 관리 정책에 따라 부담이 될 수 있음

참고자료: [패키지 매니저 선택을 위한 여정: NPM에서 Yarn으로 그리고 다시 pNPM](https://devocean.sk.com/blog/techBoardDetail.do?ID=166592)
